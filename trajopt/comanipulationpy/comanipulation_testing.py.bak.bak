#! /usr/bin/env python

import actionlib
from actionlib_msgs.msg import *
from geometry_msgs.msg import *
import math
from std_msgs.msg import Float64
import rospy
import tf
from tf import TransformListener
import numpy as np


import argparse
parser = argparse.ArgumentParser()
parser.add_argument("--interactive", action="store_true")
args = parser.parse_args()

import openravepy
import trajoptpy
import json
import time
import trajoptpy.kin_utils as ku

from comanipulationpy import *
from quantitative_tests import *
from plots import *

import sys

class QuantitativeUnitTesting:
    def __init__(self):

        if use_ros:

            self.joint_1_pub = rospy.Publisher('/j2s7s300/joint_1_position_controller/command', Float64, queue_size=3)
            self.joint_2_pub = rospy.Publisher('/j2s7s300/joint_2_position_controller/command', Float64, queue_size=3)
            self.joint_3_pub = rospy.Publisher('/j2s7s300/joint_3_position_controller/command', Float64, queue_size=3)
            self.joint_4_pub = rospy.Publisher('/j2s7s300/joint_4_position_controller/command', Float64, queue_size=3)
            self.joint_5_pub = rospy.Publisher('/j2s7s300/joint_5_position_controller/command', Float64, queue_size=3)
            self.joint_6_pub = rospy.Publisher('/j2s7s300/joint_6_position_controller/command', Float64, queue_size=3)
            self.joint_7_pub = rospy.Publisher('/j2s7s300/joint_7_position_controller/command', Float64, queue_size=3)
            self.transformer = tf.Transformer(True, rospy.Duration(10.0))
            self.tf = TransformListener()



        self.env = openravepy.Environment()
        self.env.StopSimulation()
        self.env.Load("../data/jaco-test.dae")
        # self.env.Load("../data/table.xml")
        self.env.SetDefaultViewer()

        # trajoptpy.SetInteractive(args.interactive) # pause every iteration, until you press 'p'. Press escape to disable further plotting
        self.robot = self.env.GetRobots()[0]
        print(self.robot.__dict__)
        print(self.robot.GetManipulator('test_arm'))

        joint_start = [3.0, 3.14, 0.0, 3.14, 0.0, 3.14, 0.0]
        self.robot.SetDOFValues(joint_start, self.robot.GetManipulator('test_arm').GetArmIndices())

        joint_target = [5.0, 1.8, 0.0, 3.14, 0.0, 3.14, 0.0]



        quat_target = [1,0,0,0] # wxyz
        # xyz_target = [6.51073449e-01,  -1.87673551e-01, 4.91061915e-01]
        xyz_target = self.get_eef_position(joint_target)
        # hmat_target = openravepy.matrixFromPose( np.r_[quat_target, xyz_target] )

        # print("Starting IK")
        # # BEGIN ik
        # self.manip = self.robot.GetManipulator("test_arm")
        # self.robot.SetActiveManipulator(self.manip)
        # ikmodel = openravepy.databases.inversekinematics.InverseKinematicsModel(
        #     self.robot, iktype=openravepy.IkParameterization.Type.Transform6D)
        # if not ikmodel.load():
        #     ikmodel.autogenerate()
        # init_joint_target = ku.ik_for_link(hmat_target, self.manip, "j2s7s300_ee_link",
        #     filter_options = openravepy.IkFilterOptions.CheckEnvCollisions)
        # # END ik
        # print("Finished IK")

        # print(init_joint_target)
        # joint_target = init_joint_target.tolist()

        print("Calculating straight trajectory...")
        straight_traj = np.zeros((10, 7))
        for i in range(10):
            for j in range(7):
                straight_traj[i, j] = joint_start[j] + ((joint_target[j] - joint_start[j]) * i / 9)
        print(straight_traj)
        print("Following straight trajectory")
        straight_eef_traj = self.follow_trajectory(straight_traj)
        np.savetxt('trajectories/straight.txt', straight_eef_traj, delimiter=',')

        print("Optimizing and following distance trajectory...")
        dist_eef_traj = self.distance_test(joint_start, joint_target, straight_eef_traj)

        print("Optimizing and following velocity trajectory...")
        vel_eef_traj = self.velocity_test(joint_start, joint_target, straight_eef_traj)

        print("Optimizing and following visibility trajectory...")
        vis_eef_traj = self.visibility_test(joint_start, joint_target, straight_eef_traj)

        print("Optimizing and following legibility trajectory...")
        leg_eef_traj = self.legibility_test(joint_start, joint_target, straight_eef_traj)

        print("Optimizing and following optimal trajectory...")
        opt_eef_traj = self.optimal_trajectory_test(joint_start, xyz_target, joint_target, straight_eef_traj)




    # dof_vals = 7 dimensional joint config
    def get_eef_position(self, dof_vals):
        if use_ros:
            time.sleep(1)
            self.joint_1_pub.publish(Float64(dof_vals[0]))
            self.joint_2_pub.publish(Float64(dof_vals[1]))
            self.joint_3_pub.publish(Float64(dof_vals[2]))
            self.joint_4_pub.publish(Float64(dof_vals[3]))
            self.joint_5_pub.publish(Float64(dof_vals[4]))
            self.joint_6_pub.publish(Float64(dof_vals[5]))
            self.joint_7_pub.publish(Float64(dof_vals[6]))
            time.sleep(3)
            tim = self.tf.getLatestCommonTime("/j2s7s300_ee_link", "/j2s7s300_link_base")
            position, _ = self.tf.lookupTransform("/j2s7s300_link_base", "/j2s7s300_ee_link",
                                        self.tf.getLatestCommonTime("/j2s7s300_ee_link", "/j2s7s300_link_base"))
        else:
            # print(dof_vals)
            self.robot.SetDOFValues(dof_vals, self.robot.GetManipulator('test_arm').GetArmIndices())
            posevec = openravepy.poseFromMatrix(self.robot.GetLink("j2s7s300_ee_link").GetTransform())
            position = posevec[4:7]
        # print(position)
        pos = np.array([position[0], position[1], position[2]])
        return pos

    
    def follow_trajectory(self, traj):
        num_timesteps = traj.shape[0]
        eef_traj = np.zeros((num_timesteps, 3))
        for i in range(num_timesteps):
            p_eef_t = self.get_eef_position(traj[i])
            for j in range(3):
                eef_traj[i, j] = p_eef_t[j]
            # raw_input(eef_traj[i])
        return eef_traj

    def optimize_problem(self, request):
        s = json.dumps(request)
        prob = trajoptpy.ConstructProblem(s, self.env) # Create object that stores optimization problem
        t_start = time.time()
        # sys.exit()
        result = trajoptpy.OptimizeProblem(prob) # do optimization
        t_elapsed = time.time() - t_start
        print result
        print "optimization took %.3f seconds"%t_elapsed

        # from trajoptpy.check_traj import traj_is_safe
        # prob.SetRobotActiveDOFs() # set robot DOFs to DOFs in optimization problem
        # assert traj_is_safe(result.GetTraj(), self.robot) # Check that trajectory is collision free

        return result
    


    def distance_test(self, init_joint, final_joint, ref_traj):
        self.robot.SetDOFValues(init_joint, self.robot.GetManipulator('test_arm').GetArmIndices())

        human_poses_mean = []
        human_poses_var = []
        human_poses_mean_v = []
        human_poses_var_v = []
        coeffs = []
        for i in range(10 * 3):
            num = 0.1
            num = num + i * 9
            for j in range(3):
                human_poses_mean_v.append(num + j)
            for j in range(9):
                human_poses_var_v.append(num + j)

        for i in range(10):
            human_poses_mean.append([0, 0.5, 0.8])
            human_poses_mean.append([0, 0.5, 0.6])
            human_poses_mean.append([0.2, 0.5, 0.6])
            human_poses_var.append([0.1, 0.1, 0.1])
            human_poses_var.append([0.1, 0.1, 0.1])
            human_poses_var.append([0.1, 0.1, 0.1])
            coeffs.append(1.0)

        n_human_joints = 3

        links = ["j2s7s300_ee_link", "j2s7s300_link_6", "j2s7s300_link_4"]
        links_2 = ["j2s7s300_ee_link", "j2s7s300_link_6", "j2s7s300_link_4", "j2s7s300_link_7", "j2s7s300_link_5", "j2s7s300_link_3", "j2s7s300_link_2"]

        request = create_empty_request(10, final_joint)
        add_distance_cost(request, human_poses_mean, human_poses_var, coeffs, n_human_joints, links, human_poses_mean_v, human_poses_var_v)

        result = self.optimize_problem(request)
        sys.exit()
        eef_traj = self.follow_trajectory(np.array(result.GetTraj()))

        if plot:
            plot_trajectory(eef_traj, "Distance", ref_traj, "Joint Space Linear", "plots/distance.png")

        np.savetxt('trajectories/distance.txt', eef_traj, delimiter=',')

        return self.follow_trajectory(np.array(result.GetTraj()))


    def velocity_test(self, init_joint, final_joint, ref_traj):
        self.robot.SetDOFValues(init_joint, self.robot.GetManipulator('test_arm').GetArmIndices())

        human_poses_mean = []
        human_poses_var = []
        coeffs = []
        for i in range(10):
            coeffs.append(1.0)
            human_poses_mean.append([0, 0.5, 0.8])
            human_poses_mean.append([0, 0.5, 0.6])
            human_poses_mean.append([0.2, 0.5, 0.6])
            human_poses_var.append([0.1, 0.1, 0.1])
            human_poses_var.append([0.1, 0.1, 0.1])
            human_poses_var.append([0.1, 0.1, 0.1])
        n_human_joints = 3
        links = ["j2s7s300_ee_link", "j2s7s300_link_6", "j2s7s300_link_4"]
        links_2 = ["j2s7s300_ee_link", "j2s7s300_link_6", "j2s7s300_link_4", "j2s7s300_link_7", "j2s7s300_link_5", "j2s7s300_link_3", "j2s7s300_link_2"]

        request = create_empty_request(10, final_joint)
        add_velocity_cost(request, human_poses_mean, human_poses_var, coeffs, n_human_joints, links)

        result = self.optimize_problem(request)
        eef_traj = self.follow_trajectory(np.array(result.GetTraj()))

        if plot:
            plot_trajectory(eef_traj, "Velocity", ref_traj, "Joint Space Linear", "plots/velocity.png")


        np.savetxt('trajectories/velocity.txt', eef_traj, delimiter=',')

        return self.follow_trajectory(np.array(result.GetTraj()))


    def visibility_test(self, init_joint, final_joint, ref_traj):
        self.robot.SetDOFValues(init_joint, self.robot.GetManipulator('test_arm').GetArmIndices())

        request = create_empty_request(10, final_joint)

        head_pos_mean = []
        head_pos_var = []
        coeffs = []
        for i in range(10):
            head_pos_mean.append([1, 1, 1])
            head_pos_var.append([0.1, 0.1, 0.1])
            coeffs.append(1.0)
        object_pos = [1, 0, 0]

        add_visibility_cost(request, head_pos_mean, head_pos_var, coeffs, object_pos, "j2s7s300_ee_link")

        result = self.optimize_problem(request)
        eef_traj = self.follow_trajectory(np.array(result.GetTraj()))

        if plot:
            plot_trajectory(eef_traj, "Visibility", ref_traj, "Joint Space Linear", "plots/visibility.png")

        np.savetxt('trajectories/visibility.txt', eef_traj, delimiter=',')

        return eef_traj


    def legibility_test(self, init_joint, final_joint, ref_traj):
        self.robot.SetDOFValues(init_joint, self.robot.GetManipulator('test_arm').GetArmIndices())

        coeffs = []
        for i in range(10):
            coeffs.append(1.0)

        request = create_empty_request(10, final_joint)
        add_legibility_cost(request, 1.0, "j2s7s300_ee_link")

        result = self.optimize_problem(request)
        eef_traj = self.follow_trajectory(np.array(result.GetTraj()))

        if plot:
            plot_trajectory(eef_traj, "Legibility", ref_traj, "Joint Space Linear", "plots/legibility.png")

        np.savetxt('trajectories/legibility.txt', eef_traj, delimiter=',')
        
        return self.follow_trajectory(np.array(result.GetTraj()))
        

    def optimal_trajectory_test(self, init_joint, xyz_target, final_joint, ref_traj):
        self.robot.SetDOFValues(init_joint, self.robot.GetManipulator('test_arm').GetArmIndices())

        request = create_empty_request(10, final_joint)

        xyz_target = self.get_eef_position(final_joint)
        xyz_init = self.get_eef_position(init_joint)

        add_optimal_trajectory_cost(request, xyz_init, xyz_target, "j2s7s300_ee_link", 10, 5)

        result = self.optimize_problem(request)
        eef_traj = self.follow_trajectory(np.array(result.GetTraj()))

        if plot:
            plot_trajectory(eef_traj, "Optimal Trajectory", ref_traj, "Joint Space Linear", "plots/optimal.png")

        np.savetxt('trajectories/optimal.txt', eef_traj, delimiter=',')

        return self.follow_trajectory(np.array(result.GetTraj()))



if __name__ == '__main__':

    use_ros = False
    plot = True


    if (use_ros):
        rospy.init_node('quantitative_unit_test')
    tester = QuantitativeUnitTesting()
    if (use_ros):
        rospy.spin()
    else:
        raw_input("Finished...")