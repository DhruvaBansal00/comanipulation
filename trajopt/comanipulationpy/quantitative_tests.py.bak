
# input is a 7x10 or 10x7 matrix of a trajectory
def calculate_legibility(self, dof_vals):
    num_timesteps = dof_vals.shape[0]
    d_eef_s_q = np.empty((num_timesteps - 1))
    err_ = 0
    f_t = np.ones((num_timesteps - 1))


    C_s_q = 0
    for i in range(num_timesteps - 1):
        p_eef_t = self.get_eef_position(dof_vals[i])
        # p_eef_t_ = dof_vals[i*7][7]
        # Get transform to link
        p_eef_t1 = self.get_eef_position(dof_vals[i + 1])
        # p_eef_t1_ = dof_vals[(i+1)*7][7]
        # Get transform to link
        C_s_q += np.linalg.norm(p_eef_t1_ - p_eef_t_)
        d_eef_s_q[i] = C_s_q

    p_eef_g = self.get_eef_position(dof_vals[-1])
    # p_eef_g = dof_vals[9*7][7]
    # Get transform to link
    p_eef_s = self.get_eef_position(dof_vals[0])
    # p_eef_s = dof_vals[0][7]
    # Get transform to link

    C_s_g = np.linalg.norm(p_eef_g - p_eef_s)

    for q in range(num_timesteps - 1):
        # p_eef_q = dof_vals[q*7][7]
        p_eef_q = self.get_eef_position(dof_vals[q])
        # Get transform to link
        C_q_g = np.linalg.norm(p_eef_g - p_eef_q)
        C_s_q = d_eef_s_q[i]
        # C_s_q = np.sum(d_eef_q[0][4])
        p_g_given_q = np.exp(-C_s_q - C_q_g) / np.exp(-C_s_g)
        err_ += p_g_given_q * f_t[q]

    lambda_ = 1.0
    err_ = (err_ / np.sum(f_t)) - (lambda_ * d_eef_s_q[-1])
    err = err_

    return err

def calculate_predictability(self, traj):
    num_timesteps = traj.shape[0]
    p_eef_s = self.get_eef_position(traj[0])
    p_eef_g = self.get_eef_position(traj[-1])

    optimal_traj = np.zeros((num_timesteps, 3))

    err_ = 0

    for i in range(num_timesteps):
        optimal_traj[i, 0] = p_eef_s[0] + (p_eef_g[0] - p_eef_s[0])/num_timesteps * i
        optimal_traj[i, 1] = p_eef_s[1] + (p_eef_g[1] - p_eef_s[1])/num_timesteps * i
        optimal_traj[i, 2] = p_eef_s[2] + (p_eef_g[2] - p_eef_s[2])/num_timesteps * i

        p_eef_t = self.get_eef_position(traj[i])

        err_ += np.linalg.norm(optimal_traj[i] - p_eef_t)
    
    err = err_

    return err

def calculate_visibility(self, traj):

    num_timesteps = traj.shape[0]
    head_pos = np.array([1, 1, 1])
    obj_pos = np.array([0, 0, 0])

    vec_head_obj = head_pos - obj_pos

    err_ = 0

    for i in range(num_timesteps):
        p_eef_t = self.get_eef_position(traj[i])
        vec_head_eef = head_pos - p_eef_t

        err_ += math.acos(np.dot(vec_head_obj, vec_head_eef) / (np.linalg.norm(vec_head_obj) * np.linalg.nor(vec_head_eef)))
    
    err = err_
    return err_